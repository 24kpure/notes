主要是阅读《深入理解java虚拟机》所得，用于巩固。

#### 一.虚拟机进行类加载流程

##### 1.加载

读取编译后的class，在内存中创建一个对应class对象作为之后调用的访问入口，

##### 2.验证

验证class内容

文件验证内容：例如class开头的魔数 CAFFEBABE,java版本号是否合理等

元数据验证：是否有父类，继承了不被允许继承的父类，不是抽象类是否实现父类抽象方法或接口的方法

字节码验证：判定语句语法语义是否合理

##### 3.准备

方法区（堆）中分配内存 final初始化

##### 4.解析

虚拟机中常量池内的符号引用替换为直接引用的过程

符号引用：描述指向目标。

直接引号：指向目标的指针，相对偏移量，句柄类的，能够直接标识目标的。

##### 5.初始化

调用static内容，正式开始执行用户代码

 

#### 二.双亲委派模式

主要是指类加载器

类加载具有层次关系，优先委派父类的加载器去完成，因此所有加载请求最终都传送到顶层的启动类加载器，父类反馈无法完成加载请求时，子加载器才会尝试自己去加载。

好处是类加载具有层级关系，所有类都有一个共同的父类加载器，如果用户自己重写一个object类且放入classpath中，程序也不会优先加载这个类。

现在热部署是不完全遵守双亲委派模式。

 

#### 三.虚拟机内存区域

##### 1.程序计数器

表示当前执行到哪条指令，肯定是线程私有

##### 2.虚拟机栈

线程私有，存有局部变量表，操作数栈，动态链接，方法出口学习等  个人认为局部变量表

##### 3.本地方法栈

线程私有 本地方法变量信息等 native

##### 4.堆

线程共享区域，实例和数组都在在这块区域分配的。

##### 5.方法区

线程共享区域，用于存储已经被虚拟机加载的类信息，常量，静态变量，即时变异后的代码数据。1.7之前采用永久带实现方法区，这部分的回收相对宽容。

方法区还包括运行时常量，其实也好理解，类加载流程中解析有替换常量池内的符号。

在java8中，取消了永生代即方法区，用元空间代替。原因是oracle收购了jrocket，而它并没有永生代这一概念，所以在融合二者优点的时候取消了永生代。

其实元空间和永生代在我看来并无太大的区别，不过内存方面是有差异，使用的不在是虚拟机内存。总结下，就是方法逻辑代码，字符常量池空间现在都存在虚拟机之外的内存。

 

##### 6.直接内存

不是Java虚拟机的部分，例如nio可以利用native函数直接分配堆外内存，然后通过堆中对象引用，可以避免java堆和native堆中来回复制数据。

 

#### 四.Xmx是不是越大越好？

不是 ,分配给虚拟机的内存固定时，减去Xmx和MaxPermSize，剩下的内存就有虚拟机栈和本地方法栈瓜分，线程分配的栈越大，新建线程花销也就越大，这个时候需要减少堆内存和栈容量来换取更多线程（线程数1000-2000一般问题不大）

 

#### 五.java多态实现

##### 1.静态分派

静态分派实现重载，在函数调用前就已经确定指向哪个函数

##### 2.动态分派

动态分派实现重写，优先查询本类是否有该方法，然后依次查询其父类。但是这种方法不够便捷，提供优化方案，类的虚表。重写的函数地址会直接存储在子类的虚表。

 

#### 六.java泛型

1.java泛型不同于C#，C#泛型有实际占位符，真泛型，称为类型膨胀。

2.java泛型底层采用的是类型擦除，采用类型转换，这点在无返回值的重载无法编译通过，编译器认为两个函数是一样的。在有返回值的时候，同一个class可以允许两个函数存在，因为返回值不同，因此可以重载。

 

#### 七.GC相关

1. ##### 判断对象是否可以被回收  ---- 可达性分析

虚拟机栈和本地方法区栈引用对象，方法区静态属性引用对象和常量引用的对象可以作为GCROOTS，如何在这个根节点下叶节点，都可以判断为存活。

##### 2.引用分级

强引用例如  Object o=new Object() 只要强引用在，永不回收。

软引用 在内存不紧张的时候不会回收

弱引用 只能活到下次gc前

虚引用 无法通过其获取对象实例   

总结：有毛用？

##### 3.内存收集算法（需要的话自己上网看下图 可以理解）

①标记清除  标记内存，而后清除。 缺点使内存碎片化。

结合特性 不干扰现行使用内存，适用于年老代

②复制算法 两块同等大小内存，标记不回收的，复制到另外一个内存区并清空此区内存。 缺点没有完全利用整块内存，且复制算法效率低。  

结合特性适用于新生代，新生代大部分对象朝生夕死，存活变量不高，复制成本低且新生代空间远小于年老带代（因为新生代存活时间够长，会移动到年老代）

③标记整理 标记清除后，把需要使用的内存拼成连续内存，保留了空间。  缺点：需要安全点或安全区执行，相对不灵活。

结合特性适用于年老代，cms收集器的收集算法。

##### 4.收集器

①Serial

单线程收集器，标记整理；新生代采用复制算法；

单线程效率高，无线程交互的开销。client模式下的默认收集器。

②ParNew收集器

Serial收集器的多线程版本，基本一致；新生代采用复制算法，老年代使用标记整理算法

server模式下的首选新生代收集器，因为目前只有它可以和cms收集器配合工作。

③Parallel Scavenge收集器

并行新生代收集器，采用复制算法。

此款收集器注重吞吐量，减少垃圾回收在程序总运行时间的比重。

④Parallel Old

Parallel Scavenge收集器的老年代版本

⑤Serial Old

Serial的老年代版本；老年代使用标记整理算法；作为cms的后备预案。

⑥cms收集器

老年代收集器，短暂停留，标记清理算法。

缺点 暂用大量cpu资源用于垃圾回收，无法处理浮动垃圾（在gc过程中声场的垃圾），大量空间碎片。

优点 除了标记GCROOTS需要stop the world，其它可以保证程序低延迟执行。

⑦G1收集器

时代前沿收集器（手动滑稽）

优点  并行与并发（并行是指多线程执行手机程序，并发是指在执行gc时用户程序同步运行）。分带整理（可独立处理，不需要其他收集器协助），空间整合（整体来看是标记整理，局部是复制算法），可预测停顿（指定垃圾回收不能超过多少ms）

 

暂无jvm生产调优经验，准备试试



八.调优实例

1.top查看进程，top -H  -p 进程号

2.jstack -l 原进程号> log

3.在日志中查找具体进程号（记得转16进制）

cat log|grep nid=0x(16进制进程号)